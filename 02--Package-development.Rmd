---
title: "EARL 2021 - Workshop 2: Package Development"
description: "Part 2 of the EARL 2021 - Workshops Session Package Building in R by Mango Solution"
author:
  - name: Guillaume Abgrall
    url: https://github.com/guigui351/EARL-2021-Workshops
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

# 2. Building Packages with `devtools` and `usethis`

## 2.1 Why create an R package?

Most of us won’t have started to think about writing our own packages as soon as we started to work with R. We typically start out by writing code in one or more R scripts
that contain lots of library/require calls or calls to source at the top. We might want to think about writing packages to:

- Simplify loading of code and packages
- Maintain a single version and be able to identify which version of code is being used
- Implement testing frameworks to more confidently make changes to code
- Provide documentation and usage examples of code easily

## 2.2 Working with usethis and devtools
The devtools package, written by Hadley Wickham, has been designed to simplify the package building process. usethis is a nice 
complement to devtools (from which it was split), as it helps automate some of the repetitive tasks. 

In addition, the features provided by the RStudio interface now make it so simple for us to build packages there is no reason not to do it right from the start for all of our code!

Even without the RStudio interface these packages provide a series of functions that will allow us to easily perform actions that were previously time consuming. 
From creating the basic package structure to building and checking our packages. 
This course material focuses on how we can use the devtools and usethis packages, but will reference the appropriate functionality in the RStudio interface.

In addition there are packages such as `roxygen2` and `testthat` that we can use to enhance our package building and maintenance. 
These packages allow us to more easily generate package documentation and implement a system that allows us to easily verify that changes to our code have not inadvertently impacted our outcomes. 

Throughout this course we will use the devtools and usethis packages to simplify package development but it should be noted that this is not the only way to develop a
package and all the tasks that we will perform can be done without these utilities.

## 2.3 The Structure of an R Package
R packages can contain a variety of objects such as functions and data. In addition they contain help documentation, including vignettes, demos of running the package
and, as we mentioned above, they can also include tests for functions. All of this is included in the structure of a package.

As a minimum we need 3 components in an R package:

- `DESCRIPTION` file
- `NAMESPACE` file
- `R/` directory

### 2.3.1 Creating the Package Structure

`usethis` contains a number of `create_*` functions for ease of project setup and development for R packages (and non-package projects). 

The key function to create a package is **create_package**; which we supply with a path (new or existing) to where our package should be created.

For example, let’s create a package for simple simulation tools called `simtools`.

Ensure you are in the correct working directory (getwd()) prior using `create_package` from `usethis` package. Your package will be created inside in a new folder

```{r}
library(usethis)

create_package("simtools")
```

### 2.4 The Elements of a Package

As mentioned above, all packages have a very specific structure that must be followed. 
There are additional files and directories that can be created but as a minimum we must have each of the files and directories discussed below.

### 2.4.1 Update the DESCRIPTION file

The `DESCRIPTION` file is an important file for telling users of your package information such as who wrote the package, who is maintaining the package, what the current
version of the package is and what other packages are needed to run your package among other things.

For our simtools package the `DESCRIPTION` file generated by create_package will look like this (see above)

Replace all examples fields with your personal information.

For instance, we can fix the warning we got from `check()` about licence format by using the `use_mit_license()` function:

```{r}
use_mit_license(name = "Guillaume Abgrall")
```

### 2.4.3 The R Directory

The R directory is where all of our R functions will be stored. It is good practice to include a single R script for each function. usethis provides us with a handy function
use_r which creates an R script for the function name that we provide it with, and gives us handy options to create test scripts for this file too (more on testing later).

```{r}
usethis::use_r("sample_from_data.R") 
```

Executing this in your R session will create the file sample_from_data.R in the R/ directory and opens it in the script-editor. We can then add in the function definition
and save the file.

### Exercice 1 - See page 15 from material 

Create a package called summarytools

```{r}
create_package("summarytools")

usethis::use_r("stat_summary.R") 
usethis::use_r("numeric_summary.R") 

# test the function to create summary stats for a variable
#numeric_summary(mtcars$carb)
```


## 2.5 Checking a Package

Before a package can be made available on **CRAN** it is required to pass a series of checks that can be run from the command line using R CMD check. 

Even if we don’t intend to make a package available on **CRAN** it is good practice to run this and ensure that our package passes all of the checks. 
Just like all other build features this is simplified in devtools with the function check. As with other build features we can easily access this in RStudio using the build options.

It’s a good workflow to run `check` early and often. Try and ensure that all checks are passed at each new stage of development and **don’t move onto a new task until the
checks are satisfied**. Let’s run `check()` on our empty package:

```{r}
library(devtools)
check("./simtools")
```

As you can see the check function in devtools additionally updates the documentation for the package (i.e. it runs the document function - which we will see later in this
course) before running the checks. If there are any problems with the package this will be detailed in the output and we can then work to fix those issues. Re-running the
check function will tell us if the package is now in a suitable format to be built and distributed.

## 2.6 Building a Package

Once we have created the correct structure, including all of our functions, created the package documentation and ensured that the checks pass we can then build our
package so that it is in a shareable format!!

We can build our package using the `build` function of **`devtools`**. 

We can use this function to build either a source version of the package or a Windows/Mac specific binary version. 
The source version of the package will have a file ending of “.tar.gz” and the binary will take the ending “.zip” (Windows) or “.tgz” (Mac).

```{r}
build("./simtools")
```

## 2.7 Installing and Running our Packages

Once we have built our package and we are happy that it is suitable for use we can install and run in the same way we would do for any other package in R. 

This may be done by using the RStudio install interface and selecting “Package Archive File” from the “Install From” menu, or by running `install.packages`.

```{r}
install.packages("./simtools_0.0.1.tar.gz", repos = NULL, type = "source")
library(simtools)
```


## 2.8 Interactive Development

During the package development cycle we want try out features of our package to ensure that they work as expected. Having to build and install the package repeatedly
is time consuming, especially if this is to test just one small tweak to the package. We can instead use the load_all function in devtools to load the code as though it were
a package. We can then try out the functionality, make any other changes and reload to try again.

Let’s load our package and try out **`sample_from_data`**

```{r}
#load_all()
sample_from_data(airquality, 2)
```

# 3. Documenting Functions using `roxygen2`

## 3.1 Package Documentation

To the end user the most important part of your package is the documentation. A package that is well documented is much easier for someone to pick up and work with
and it’s much easier to return to when you need to update or change the functionality in the future.

Function help files list all of the arguments and detail the purpose and usage of each.

We can also add information about the output of the function, additional details about the function, who wrote the function and so on. We are going to generate the
documentation using `roxygen` headers that will be converted to package documentation with the `roxygen2` package.

## 3.2 Documenting Functions

### 3.2.1 Roxygen Headers

We include a roxygen header above the function definition. 

Each line of the roxygen header starts with the symbols **“#”**. This is known as a roxygen comment. 
Following this we use special tags to indicate a particular component of the help file. However the first three elements have special meaning!

The first three paragraphs of the header are treated as:
1. The title of the help page (short, one sentence)
2. The description for the help page (brief description of the function)
3. The details section which can provide much more information about the function, what it implements etc.

Following these lines we must use the tags to distinguish elements. These tags all start with an **“@”** symbol. 

Some tags and their uses are:

| **Tag**             | **Purpose**                                                                        | 
| :-------------      | :------------------------------------------------------------------------------    | 
| @param              | Identify each of the function arguments and the corresponding help text            | 
| @return             | Detail the output of the function                                                  | 
| @author             | Who wrote this function?                                                           | 
| @seealso            | Other functions that the user should also look at the help documentation for       | 
| @examples           | Code examples of running the function                                              | 
| @import/@importFrom | Indicate a package or function within a package to be imported                     | 
| @export             | Indicate that this function should be exported (i.e. made visible to the end user) | 


The following is an example of how this might look for an example function in the
simtools package we created earlier.

```{r}
#' Sample from a dataset
#'
#' This function has been designed to sample from the rows of a two
#' dimensional data set returning all columns of the sampled rows.
#'
#' @param data The matrix or data.frame from which rows are to be
#' sampled.
#' @param size The number of samples to take.
#' @param replace Should values be replaced? By default takes the
#' value TRUE.
#' @param ... Any other parameters to be passed to the sample
#' function
#'
#' @return Returns a dataset of the same type as the input data with
#' \code{size} rows.
#'
#' @export
#' @examples
#' sample_from_data(airquality, 10)
#'

sample_from_data <- function(data, size, replace = FALSE, ...){
  
  length_data <- nrow(data)

  sample_rows <- sample(1:length_data, size, replace = replace, ...)

  data[sample_rows, ]
}
```

## 3.3 Creating and Updating the man Files

Once we have created function headers and the package help file we can create the “.Rd” files for the package using the document function in devtools. 
The primary argument to this function is the file path to the top level of the package.

```{r}
usethis::document("./simtools")
```

Note that you may first need to “Configure Build Tools” in RStudio to see this option. If
`roxygen2` is installed you will have a configuration option to use `roxygen2` to document a package.

Once the man files have been created these can be opened and previewed in RStudio. They will be opened in the usual RStudio help pane. 
Once the package documentation has been generated you can preview using the usual `?`.

```{r}
?sample_from_data
```

!!! If your package function uses any other functions from external packages they should be included in the roxygen header, e.g.:

```{r}
#' @importFrom dplyr slice.
```


Refer to the function within your code including the package name e.g. **`dplyr::slice`**

Once `devtools::document()` is run these external functions will be correctly added into the `NAMESPACE` file.
You will also need to run a `usethis::use_package('dplyr')` to make sure the package is added to the imports section of the `DESCRIPTION` file.


# 4. Testing Code using testthat

## 4.1 Unit Tests

A component that we should consider including whenever we write code is unit tests.

Unit tests allow us to:
- Formalise ad-hoc testing we usually perform
- Verify that our code satisfies requirements
- Make changes to the code and know it hasn’t changed the functionality
- Track bugs and ensure they do not get re-introduced into code

There are a number of ways of writing unit tests in R but the simplest is to use the
package **`testthat`**. 

Another Hadley Wickham package, this makes it very simple to test all components of a package in a simple manner!

## 4.2 Setting up the Test Framework

We can set up a test framework in a package using the function use_testthat from package `usethis`.

```{r}
use_testthat()
```

This will create a test directory that contains:

- A script `testthat.R` that contains all the code required to run the package tests
- A directory `testthat` where we will save all of our test scripts

The `use_testthat` function will also update the `DESCRIPTION` file accordingly to include
testthat as a suggested package.


## 4.3 Writing tests

We can think of tests as a collection of expectations. For instance, given a valid input,
our function `sample_from_data` would be expected to:

- return a data frame
- return an output with the number of rows we have asked for have data that comes from the initial inputted data

These are the sorts of expectations we check ad-hoc during development but we would like to encapsulate the essence of each expectation into a **unit test**.
With the package `testthat` we compose tests out of individual expectations using functions named with the pattern `expect_*.` 

Some of the most common expect statements are given in the following table:

| **Expectation**           | **Description**                                                                    | 
| :-------------            | :------------------------------------------------------------------------------    | 
| @expect_identical         | Checks for exact quality                                                           | 
| @expect_equal             | Checks for equality with numerical tolerance                                       | 
| @expect_equivalent        | WMore relaxed version of equals                                                    | 
| @expect_type              | expect_type/expect_s3_class, etc. Checks than an object inherits a specified class | 
| @expect_matches           | Compares a character vector to a regular expression                                | 
| @expect_true              | Checks that the logical TRUE is returned                                           | 
| @expect_false             | Checks that the logical FALSE is returned                                          | 
| @expect_error             | Checks that an expression throws an error                                          | 
| @expect_warning           | Checks that an expression gives a warning                                          | 
| @expect_message           | Checks that an expression issues a message                                         | 


Suppose that we want to test our sample_from_data function. We can set up a test file
using the usethis function use_test:

```{r}
test_that("multiplication works", {
  expect_equal(2 * 2, 4)
})
```

It’s a single test, ‘multiplication works’, which contains a single expectation that the expressions “2 * 2” and “4” are equal. 

Let’s change the contents to reflect the set of expectations we listed earlier for sample_from_data:

```{r}
# check object returned
test_data <- sample_from_data(airquality, 3)
expect_s3_class(test_data, "data.frame")

# check number of rows
rows <- 6
test_data <- sample_from_data(airquality, rows)
expect_equal(nrow(test_data), rows)

# check we have output data from input data
set.seed(20)
test_data <- sample_from_data(airquality, 3)
expect_equal(test_data, airquality[c(107, 120, 130), ])
```

To run tests in packages we need to group these individual expectations together that
test specific functionality. We do this using a function `test_that`.

```{r}
test_that("returns a data frame", {
  test_data <- sample_from_data(airquality, 3)
  expect_s3_class(test_data, "data.frame")
})

test_that("returns the number of rows specified by the function", {
  rows <- 6
  test_data <- sample_from_data(airquality, rows)
  expect_equal(nrow(test_data), rows)
})

test_that("The data returned is within the original data", {
  set.seed(20)
  test_data <- sample_from_data(airquality, 3)
  expect_equal(test_data, airquality[c(107, 120, 130), ])
})
```

### 4.3.1 Error Testing

While above we have checked that the function works as it should, we should also be checking that our function errors correctly as it should. 

If we update our summary_from_data function slightly to include checks that we don’t take a sample larger than the data (unless if we’re replacing), 
and to ensure that the size value is numeric, we can test as follows;

```{r}
test_that("Throws an error correctly", {

  expect_error(sample_from_data(airquality, "Subject"),
               "Size must be a numeric integer value")
  my_data <- data.frame("a" = 1:4, "b" = 4:1)
  expect_error(sample_from_data(my_data, 10), "Cannot sample greater than the data size without replacement")
  expect_error(sample_from_data(my_data, 10, replace = TRUE), NA)
})
```

## 5. Writing User Guides

### 5.1 User Guides

User guides, or Vignettes as they are known in R, are a way of extending the help pages of a package to describe the workflow or give more details of what the package
does and how it has been implemented.

Vignettes can be written using the `Sweave` function that is part of the base R, or any package that generates HTML or pdf files.

We are going to use knitr which allows us to use R Markdown, a simple markup language.

### 5.2 Including a Vignette

The package structure for a vignette and a template file that we can start from can be created using the **`use_vignette`** function from `usethis`. This will also appropriately
update the `DESCRIPTION` file for us.

```{r}
use_vignette("introduction-to-simtools", "Introduction to simtools")
```

This will open up in a *script* for us with an appropriate header and the package loaded in:

```{r}
#---
#title: "Introduction to simtools"
#output: rmarkdown::html_vignette
#vignette: >
#  %\VignetteIndexEntry{Introduction to simtools}
#  %\VignetteEngine{knitr::rmarkdown}
#  %\VignetteEncoding{UTF-8}
#---
```

```{r}
#knitr::opts_chunk$set(
#  collapse = TRUE,
#  comment = "#>"
#)
```

```{r}
#library(simtools)
```

Under this header we can start to write our document. We can simply start writing text, but to include headers and other formatting we need to use some markdown syntax.

**The following table includes some of the most common formatting elements you may want to use: **

| **Code**      | 
| :------------ | 
| `# Header 1`                |
| `## Header 2`               |
| `### Header 3`              |
| `*italic*, \_italic\_`      |        
| `**bold**, \_\_bold\_\_`    |  
| `text^superscript^`         |
| `~~strikethrough~~`         |     
| `* Item 1`                  |
| `* Item 2`                  |
| `1. Item 1`                 | 
| `2. Item 2`                 | 
| `[Text as link](http://www.example.com)`| 
| `> This is a block quote`   | 


`
This guide is intended as a means of quickly getting started with the
package **simTools**. It will introduce the main workflow of the package.

```{r}
##' Getting Started
#'The main function in the **simTools** package is `sample_from_data`. This
#'function will allow you to generate random samples from a given data set.
#'It is useful for simulation experiments.

###' Loading the package
#'Before starting you will need to load the package in the usual way using
#'either `library` or `require`.

###' Running the main function
#'Once the package is loaded we can run the function as follows:
```

Whilst we may simply want to create a vignette that contains text it is much more likely that we want to include code examples and output to demonstrate usage of a function.
We can’t simply write it in our script it has to be included in a way that identifies it as R code that should be run. We do this by including *`“chunks”`*:

```{r}
example <- sample_from_data(mtcars, size = 20, replace = TRUE)
```

*We can include any executable code that we wish including code that generates graphics.*

Inside the curly brackets we can include a number of additional options to control if and how the code is run and output:

|Option     |Values                          | Behaviour                                                                                                                                  |
|:--------  |:---------------------------:   | :------------------------------------------------------------------------------------------------------------------------------------------|
|`echo`     |`TRUE/FALSE`                    | Controls whether R code is returned to the report|
|`eval`     |`TRUE/FALSE`                    | Controls whether a code chunk is run and evaluated. This can be useful for displaying code in a report that we do not actually want to run.|
|`collapse` |`TRUE/FALSE`                    | Collapses the R code and output into a single block|
|`include`  |`TRUE/FALSE`                    | Determines whether the chunk is include. If FALSE the code is run but nothing is included in the report relating to this chunk|
|`results`  |`markup`, `"asis"`, `"hold"`, `"hide"`| Controls how the outputs are displayed. “markup” will mark up the results, “asis” will return the results in raw R, “hold” will not output until after the whole chunk has been evaluated, “hide” will hide the R output.|
|`comment`  |`##`                            | The output will have the character string “##” prepended to each line. Setting to NA will disable this.|
|`prompt`   |`TRUE/FALSE`                    | Whether or not to display the “>” prompt before lines of code|


## 5.3 Building a Vignette

During development of the vignette you can preview using the **`“Knit”`** button at the top of the file viewer in RStudio.

The vignette will be automatically built when the package itself is built so there is no need to do this prior to the check and build process.

We can also use the devtools install function on the folder containing our package, which runs the build and install for us. 
Using this with **`build_vignettes=TRUE`** we can easily access our vignettes during development:

```{r}
devtools::install(pkg="../simtools", build_vignettes = TRUE)
vignette("introduction-to-simtools", package="simTools")
```

